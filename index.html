<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

  <!-- PWA Meta Tags -->
  <meta name="theme-color" content="#ffffff" />
  <meta name="description" content="Explore rich history with immersive guided audio tours" />
  <link rel="manifest" href="/manifest.webmanifest" />

  <!-- iOS Specific -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="apple-mobile-web-app-title" content="AudioTour" />
  <link rel="apple-touch-icon" href="/icons/icon-192x192.png" />

  <title>Audio Tour Pro</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto+Condensed:wght@400;500;600;700&display=swap"
    rel="stylesheet">
  <style>
    /* Ensure full viewport height including safe areas */
    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    /* Hide scrollbar for Chrome, Safari and Opera */
    .no-scrollbar::-webkit-scrollbar {
      display: none;
    }

    /* Hide scrollbar for IE, Edge and Firefox */
    .no-scrollbar {
      -ms-overflow-style: none;
      /* IE and Edge */
      scrollbar-width: none;
      /* Firefox */
    }
  </style>
  <script type="importmap">
{
  "imports": {
    "framer-motion": "https://aistudiocdn.com/framer-motion@^12.23.24",
    "lucide-react": "https://aistudiocdn.com/lucide-react@^0.554.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0"
  }
}
</script>
</head>

<body>
  <div id="root">
    <!-- Loading indicator shown while app initializes -->
    <div id="loading-screen"
      style="display: flex; align-items: center; justify-content: center; height: 100vh; font-family: 'Inter', sans-serif; color: #666;">
      <div style="text-align: center;">
        <div
          style="width: 40px; height: 40px; border: 3px solid #f3f3f3; border-top: 3px solid #3498db; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 16px;">
        </div>
        <div id="loading-status">Loading...</div>
        <div id="debug-info" style="margin-top: 20px; font-size: 12px; color: #999; max-width: 300px;"></div>
      </div>
    </div>
    <style>
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }

        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </div>
  <script>
    // Development mode detection (hostname-based for inline scripts)
    const DEV_MODE = window.location.hostname === 'localhost' ||
                     window.location.hostname.includes('192.168') ||
                     window.location.hostname.includes('127.0.0.1') ||
                     window.location.search.includes('debug=true');

    // Visual debug helper
    function updateDebugInfo(message) {
      if (!DEV_MODE) return;
      const debugDiv = document.getElementById('debug-info');
      if (debugDiv) {
        debugDiv.innerHTML += message + '<br>';
      }
    }

    function updateLoadingStatus(message) {
      if (!DEV_MODE) return;
      const statusDiv = document.getElementById('loading-status');
      if (statusDiv) {
        statusDiv.textContent = message;
      }
    }

    // Register service worker immediately for better offline support on iOS
    if (DEV_MODE) {
      console.log('[APP] Starting SW registration...');
      updateDebugInfo('Starting...');
      updateDebugInfo('Online: ' + (navigator.onLine ? 'YES' : 'NO'));
      console.log('[APP] Online status:', navigator.onLine ? 'ONLINE' : 'OFFLINE');
      console.log('[APP] Expected SW version: 1.0.3-NAVIGATION-FIX');
    }

    if ('serviceWorker' in navigator && !/localhost/.test(window.location)) {
      navigator.serviceWorker.register('/sw.js', { scope: '/' })
        .then(registration => {
          if (DEV_MODE) {
            console.log('[APP] ‚úÖ SW registered successfully');
            console.log('[APP] SW state:', {
              installing: registration.installing ? 'yes' : 'no',
              waiting: registration.waiting ? 'yes' : 'no',
              active: registration.active ? 'yes' : 'no',
              scope: registration.scope,
              updateViaCache: registration.updateViaCache
            });

            if (registration.active) {
              console.log('[APP] Active SW state:', registration.active.state);
              console.log('[APP] Active SW URL:', registration.active.scriptURL);
            }
          } else {
            // Minimal production logging
            console.log('[APP] Service worker registered');
          }

          // Force update check
          registration.update().then(() => {
            if (DEV_MODE) {
              console.log('[APP] ‚úÖ SW update check completed');
            }
          }).catch(err => {
            if (DEV_MODE) {
              console.log('[APP] SW update check failed:', err);
            }
          });

          // Listen for SW state changes (dev only)
          if (DEV_MODE) {
            registration.addEventListener('updatefound', () => {
              console.log('[APP] SW update found!');
              const newWorker = registration.installing;
              if (newWorker) {
                newWorker.addEventListener('statechange', () => {
                  console.log('[APP] SW state changed to:', newWorker.state);
                });
              }
            });
          }
        })
        .catch(err => {
          // Always log errors
          console.error('[APP] ‚ùå SW registration failed:', err);
        });

      // Log when SW controller changes (dev only)
      if (DEV_MODE) {
        navigator.serviceWorker.addEventListener('controllerchange', () => {
          console.log('[APP] SW controller changed - new SW is now active');
        });
      }

      // Check current controller (dev only)
      if (DEV_MODE) {
        if (navigator.serviceWorker.controller) {
          console.log('[APP] Page is currently controlled by SW:', navigator.serviceWorker.controller.scriptURL);
          updateDebugInfo('‚úÖ SW Active');
        } else {
          console.log('[APP] ‚ö†Ô∏è Page is NOT controlled by any SW yet');
          updateDebugInfo('‚ö†Ô∏è No SW');
        }
      }
    } else {
      if (DEV_MODE) {
        console.log('[APP] SW not supported or running on localhost');
        updateDebugInfo('‚ùå SW not supported');
      }
    }

    // Monitor online/offline status (dev only)
    if (DEV_MODE) {
      window.addEventListener('online', () => {
        console.log('[APP] Network: ONLINE');
        updateDebugInfo('Network: ONLINE');
      });
      window.addEventListener('offline', () => {
        console.log('[APP] Network: OFFLINE');
        updateDebugInfo('Network: OFFLINE');
      });
    }

    // Catch any errors during load
    window.addEventListener('error', (event) => {
      // Always log errors
      console.error('[APP] Error:', event.error);
      if (DEV_MODE) {
        updateLoadingStatus('Error loading!');
        updateDebugInfo('‚ùå ' + (event.error?.message || event.message || 'Unknown error'));
      }
    });

    // Update loading status (dev only)
    if (DEV_MODE) {
      setTimeout(() => {
        updateLoadingStatus('Loading React...');
      }, 1000);
    }

    // Inspect cache contents after page loads (dev only)
    if (DEV_MODE) {
      window.addEventListener('load', async () => {
        console.log('[APP] üîç Inspecting cache contents...');

        try {
          const cacheNames = await caches.keys();
          console.log('[APP] Found caches:', cacheNames);

          for (const cacheName of cacheNames) {
            const cache = await caches.open(cacheName);
            const requests = await cache.keys();
            console.log(`[APP] Cache "${cacheName}" contains ${requests.length} entries:`);

            // Log first 10 URLs from each cache
            requests.slice(0, 10).forEach(req => {
              console.log(`  - ${req.url}`);
            });

            if (requests.length > 10) {
              console.log(`  ... and ${requests.length - 10} more`);
            }

            // Check specifically for CDN resources
            const cdnResources = requests.filter(req =>
              req.url.includes('aistudiocdn.com')
            );
            if (cdnResources.length > 0) {
              console.log(`[APP] ‚úÖ Found ${cdnResources.length} CDN resources in this cache`);
            }
          }

          // Check for critical CDN resources
          const criticalUrls = [
            'https://aistudiocdn.com/react@^19.2.0',
            'https://aistudiocdn.com/react-dom@^19.2.0',
            'https://aistudiocdn.com/framer-motion@^12.23.24',
            'https://aistudiocdn.com/lucide-react@^0.554.0'
          ];

          console.log('[APP] Checking for critical CDN resources...');
          for (const url of criticalUrls) {
            const response = await caches.match(url);
            if (response) {
              console.log(`[APP] ‚úÖ CACHED: ${url}`);
            } else {
              console.log(`[APP] ‚ùå NOT CACHED: ${url}`);
            }
          }

          console.log('[APP] üîç Cache inspection complete!');
        } catch (err) {
          console.error('[APP] Error inspecting caches:', err);
        }
      });
    }
  </script>
  <script type="module" src="/index.tsx"></script>
</body>

</html>