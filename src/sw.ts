/// <reference lib="webworker" />
import { precacheAndRoute, cleanupOutdatedCaches, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import { CacheFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { clientsClaim } from 'workbox-core';

declare const self: ServiceWorkerGlobalScope;

// Development mode detection - Vite will tree-shake this in production
const DEV_MODE = import.meta.env.DEV;
const SW_VERSION = '1.3.0-STORAGE-AGNOSTIC';

if (DEV_MODE) {
  console.log(`[SW ${SW_VERSION}] Service Worker initializing...`);
  console.log(`[SW ${SW_VERSION}] âš¡ Storage-agnostic version - works with any CDN/storage provider`);
}

// Critical CDN dependencies that MUST be cached for offline use
const CRITICAL_CDN_URLS = [
  'https://aistudiocdn.com/react@^19.2.0',
  'https://aistudiocdn.com/react-dom@^19.2.0',
  'https://aistudiocdn.com/framer-motion@^12.23.24',
];

// Warmup cache: Pre-fetch critical CDN resources during install
async function warmupCache() {
  if (DEV_MODE) {
    console.log(`[SW ${SW_VERSION}] ðŸ”¥ Warming up cache with CDN dependencies...`);
  }
  const cache = await caches.open('external-dependencies');

  const fetchPromises = CRITICAL_CDN_URLS.map(async (url) => {
    try {
      if (DEV_MODE) console.log(`[SW ${SW_VERSION}] Fetching ${url}...`);
      const response = await fetch(url, { mode: 'cors', credentials: 'omit' });
      if (response.ok) {
        await cache.put(url, response);
        if (DEV_MODE) console.log(`[SW ${SW_VERSION}] âœ… Cached ${url}`);
      } else {
        console.error(`[SW ${SW_VERSION}] âŒ Failed to fetch ${url}: ${response.status}`);
      }
    } catch (error) {
      console.error(`[SW ${SW_VERSION}] âŒ Error fetching ${url}:`, error);
    }
  });

  await Promise.all(fetchPromises);
  if (DEV_MODE) {
    console.log(`[SW ${SW_VERSION}] ðŸ”¥ Cache warmup complete!`);
  }
}

// Force the new service worker to take control immediately
self.skipWaiting();
clientsClaim();

// Clean up old caches from previous versions
cleanupOutdatedCaches();

// Log install event and warmup cache
self.addEventListener('install', (event) => {
  if (DEV_MODE) {
    console.log(`[SW ${SW_VERSION}] INSTALL event - precaching assets`);
  }
  event.waitUntil(warmupCache());
});

// Log activate event
self.addEventListener('activate', (event) => {
  if (DEV_MODE) {
    console.log(`[SW ${SW_VERSION}] ACTIVATE event - taking control`);
  }
});

// Precache all assets generated by Vite
if (DEV_MODE) {
  console.log(`[SW ${SW_VERSION}] Calling precacheAndRoute...`);
}
const manifest = self.__WB_MANIFEST;
if (DEV_MODE) {
  console.log(`[SW ${SW_VERSION}] Precache manifest has ${manifest.length} entries`);
}
precacheAndRoute(manifest);

// CRITICAL: Register navigation route to serve index.html for all navigation requests
const navigationHandler = createHandlerBoundToURL('/index.html');
const navigationRoute = new NavigationRoute(navigationHandler, {
  denylist: [/^\/_/, /\/[^/?]+\.[^/]+$/],
});
registerRoute(navigationRoute);
if (DEV_MODE) {
  console.log(`[SW ${SW_VERSION}] âœ… Registered navigation route handler`);
}

// Helper: Check if URL is from same origin (app files)
const isSameOrigin = (url: URL) => url.origin === self.location.origin;

// Helper: Check if URL is an audio file
const isAudioFile = (url: URL) =>
  url.pathname.endsWith('.mp3') ||
  url.pathname.endsWith('.wav') ||
  url.pathname.endsWith('.m4a') ||
  url.pathname.endsWith('.ogg') ||
  url.pathname.endsWith('.aac');

// Helper: Check if URL is an image file
const isImageFile = (url: URL) =>
  url.pathname.endsWith('.jpg') ||
  url.pathname.endsWith('.jpeg') ||
  url.pathname.endsWith('.png') ||
  url.pathname.endsWith('.webp') ||
  url.pathname.endsWith('.gif') ||
  url.pathname.endsWith('.svg');

// Helper: Check if URL is a video file
const isVideoFile = (url: URL) =>
  url.pathname.endsWith('.mp4') ||
  url.pathname.endsWith('.webm') ||
  url.pathname.endsWith('.mov');

// Helper: Check if URL is a 3D model file
const is3DModelFile = (url: URL) =>
  url.pathname.endsWith('.glb') ||
  url.pathname.endsWith('.gltf');

// App Shell - Cache First (same-origin only)
registerRoute(
  ({ url }) => isSameOrigin(url),
  new CacheFirst({
    cacheName: 'app-shell',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

// External CDN Dependencies (React, Framer Motion) - Cache First
registerRoute(
  /^https:\/\/aistudiocdn\.com\/.*/i,
  new CacheFirst({
    cacheName: 'external-dependencies',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Unsplash Images - Cache First
registerRoute(
  /^https:\/\/images\.unsplash\.com\/.*/i,
  new CacheFirst({
    cacheName: 'tour-images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Google Fonts Stylesheets - Cache First
registerRoute(
  /^https:\/\/fonts\.googleapis\.com\/.*/i,
  new CacheFirst({
    cacheName: 'google-fonts-stylesheets',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  })
);

// Google Font Files - Cache First
registerRoute(
  /^https:\/\/fonts\.gstatic\.com\/.*/i,
  new CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  })
);

// ============================================================================
// TOUR ASSETS - Storage Agnostic (works with ANY CDN/storage provider)
// These routes match by file extension, not by origin, so they work with:
// Cloudflare R2, AWS S3, Supabase Storage, Google Cloud Storage, Azure Blob,
// self-hosted servers, or any other storage provider.
// ============================================================================

// Audio Files - Hybrid Strategy (any external origin)
// Online: Network request (preserves Safari Range Request support for seeking)
// Offline: Serve from cache (audio plays from downloaded content)
registerRoute(
  ({ url }) => !isSameOrigin(url) && isAudioFile(url),
  async ({ request, url }) => {
    const cacheName = 'tour-assets';

    if (DEV_MODE) {
      console.log(`[SW ${SW_VERSION}] ðŸŽµ Audio request: ${url.href}, online: ${navigator.onLine}`);
    }

    // OFFLINE: Serve from cache
    if (!navigator.onLine) {
      const cache = await caches.open(cacheName);
      const cachedResponse = await cache.match(request, { ignoreVary: true });

      if (cachedResponse) {
        if (DEV_MODE) {
          console.log(`[SW ${SW_VERSION}] âœ… Serving audio from cache (offline)`);
        }
        return cachedResponse;
      }

      console.warn(`[SW ${SW_VERSION}] âš ï¸ Audio not cached for offline: ${url.href}`);
      return new Response('Audio not available offline. Please download the tour first.', {
        status: 503,
        statusText: 'Service Unavailable',
        headers: { 'Content-Type': 'text/plain' }
      });
    }

    // ONLINE: Use network directly (preserves Range request support for Safari)
    try {
      return await fetch(request);
    } catch (error) {
      // Network failed - try cache as fallback
      if (DEV_MODE) {
        console.log(`[SW ${SW_VERSION}] âš ï¸ Network failed, trying cache fallback`);
      }
      const cache = await caches.open(cacheName);
      const cachedResponse = await cache.match(request, { ignoreVary: true });
      if (cachedResponse) {
        if (DEV_MODE) {
          console.log(`[SW ${SW_VERSION}] âœ… Serving audio from cache (network fallback)`);
        }
        return cachedResponse;
      }
      throw error;
    }
  }
);

// Image Files - Cache First with tour-assets fallback (any external origin)
// First checks tour-assets cache (from download manager), then uses CacheFirst strategy
registerRoute(
  ({ url }) => !isSameOrigin(url) && isImageFile(url),
  async ({ request, url }) => {
    const tourAssetsCache = await caches.open('tour-assets');

    // First check if it's in tour-assets (downloaded via download manager)
    const cachedResponse = await tourAssetsCache.match(request, { ignoreVary: true });
    if (cachedResponse) {
      if (DEV_MODE) {
        console.log(`[SW ${SW_VERSION}] ðŸ–¼ï¸ Serving image from tour-assets cache: ${url.pathname}`);
      }
      return cachedResponse;
    }

    // Not in tour-assets, try network with caching
    try {
      const response = await fetch(request);
      if (response.ok) {
        // Cache in tour-images for opportunistic caching
        const imageCache = await caches.open('tour-images');
        imageCache.put(request, response.clone());
      }
      return response;
    } catch (error) {
      // Network failed, check tour-images cache
      const imageCache = await caches.open('tour-images');
      const fallbackResponse = await imageCache.match(request, { ignoreVary: true });
      if (fallbackResponse) {
        return fallbackResponse;
      }
      throw error;
    }
  }
);

// Video Files - Cache First (any external origin)
registerRoute(
  ({ url }) => !isSameOrigin(url) && isVideoFile(url),
  async ({ request, url }) => {
    const cacheName = 'tour-assets';
    const cache = await caches.open(cacheName);

    // Check cache first
    const cachedResponse = await cache.match(request, { ignoreVary: true });
    if (cachedResponse) {
      if (DEV_MODE) {
        console.log(`[SW ${SW_VERSION}] ðŸŽ¬ Serving video from cache: ${url.pathname}`);
      }
      return cachedResponse;
    }

    // Not cached, fetch from network
    try {
      const response = await fetch(request);
      if (response.ok) {
        cache.put(request, response.clone());
      }
      return response;
    } catch (error) {
      console.warn(`[SW ${SW_VERSION}] âš ï¸ Video not available: ${url.href}`);
      throw error;
    }
  }
);

// 3D Model Files - Cache First (any external origin)
registerRoute(
  ({ url }) => !isSameOrigin(url) && is3DModelFile(url),
  async ({ request, url }) => {
    const cacheName = 'tour-assets';
    const cache = await caches.open(cacheName);

    // Check cache first
    const cachedResponse = await cache.match(request, { ignoreVary: true });
    if (cachedResponse) {
      if (DEV_MODE) {
        console.log(`[SW ${SW_VERSION}] ðŸŽ¨ Serving 3D model from cache: ${url.pathname}`);
      }
      return cachedResponse;
    }

    // Not cached, fetch from network
    try {
      const response = await fetch(request);
      if (response.ok) {
        cache.put(request, response.clone());
      }
      return response;
    } catch (error) {
      console.warn(`[SW ${SW_VERSION}] âš ï¸ 3D model not available: ${url.href}`);
      throw error;
    }
  }
);

// ============================================================================
// Navigation Handler for iOS Standalone Mode
// ============================================================================

self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);
  const isNavigationRequest = event.request.mode === 'navigate';

  if (DEV_MODE) {
    console.log(`[SW ${SW_VERSION}] FETCH ${event.request.method} ${url.href}`, {
      mode: event.request.mode,
      destination: event.request.destination,
      isNavigation: isNavigationRequest,
    });
  }

  // Explicitly handle navigation requests by serving index.html from cache
  if (isNavigationRequest) {
    if (DEV_MODE) {
      console.log(`[SW ${SW_VERSION}] ðŸŽ¯ Navigation request - serving index.html`);
    }

    event.respondWith(
      (async () => {
        try {
          // Try network first when online
          if (navigator.onLine) {
            try {
              const networkResponse = await fetch(event.request);
              if (networkResponse.ok) {
                return networkResponse;
              }
            } catch {
              // Network failed, fall through to cache
            }
          }

          // Serve from cache
          const cache = await caches.open('workbox-precache-v2-' + self.location.origin + '/');
          const keys = await cache.keys();
          const indexEntry = keys.find(req => req.url.includes('index.html'));

          if (indexEntry) {
            const cachedResponse = await cache.match(indexEntry);
            if (cachedResponse) {
              if (DEV_MODE) {
                console.log(`[SW ${SW_VERSION}] âœ… Serving index.html from cache`);
              }
              return cachedResponse;
            }
          }

          console.error(`[SW ${SW_VERSION}] âŒ index.html not found in cache!`);
          return new Response('Offline - index.html not cached', {
            status: 503,
            headers: { 'Content-Type': 'text/plain' }
          });
        } catch (error) {
          console.error(`[SW ${SW_VERSION}] âŒ Error handling navigation:`, error);
          return new Response('Service Worker Error: ' + (error as Error).message, {
            status: 500,
            headers: { 'Content-Type': 'text/plain' }
          });
        }
      })()
    );
  }
});

// Clean up old caches
self.addEventListener('activate', (event) => {
  if (DEV_MODE) {
    console.log(`[SW ${SW_VERSION}] ACTIVATE - cleaning old caches`);
  }
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      if (DEV_MODE) {
        console.log(`[SW ${SW_VERSION}] Found caches:`, cacheNames);
      }
      return Promise.all(
        cacheNames
          .filter((cacheName) => {
            const shouldDelete = !cacheName.match(
              /^(app-shell|external-dependencies|tour-images|google-fonts-stylesheets|google-fonts-webfonts|tour-assets|workbox-precache)/
            );
            if (DEV_MODE && shouldDelete) {
              console.log(`[SW ${SW_VERSION}] Deleting old cache: ${cacheName}`);
            }
            return shouldDelete;
          })
          .map((cacheName) => caches.delete(cacheName))
      );
    })
  );
});
