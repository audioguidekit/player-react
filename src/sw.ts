/// <reference lib="webworker" />
import { precacheAndRoute, cleanupOutdatedCaches, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import { CacheFirst, NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { clientsClaim } from 'workbox-core';

declare const self: ServiceWorkerGlobalScope;

// Development mode detection - Vite will tree-shake this in production
const DEV_MODE = import.meta.env.DEV;
const SW_VERSION = '1.0.3-NAVIGATION-FIX';

if (DEV_MODE) {
  console.log(`[SW ${SW_VERSION}] Service Worker initializing...`);
  console.log(`[SW ${SW_VERSION}] âš¡ This is the NEW service worker with navigation handler and CDN warmup!`);
}

// Critical CDN dependencies that MUST be cached for offline use
const CRITICAL_CDN_URLS = [
  'https://aistudiocdn.com/react@^19.2.0',
  'https://aistudiocdn.com/react-dom@^19.2.0',
  'https://aistudiocdn.com/framer-motion@^12.23.24',
  'https://aistudiocdn.com/lucide-react@^0.554.0',
];

// Warmup cache: Pre-fetch critical CDN resources during install
async function warmupCache() {
  if (DEV_MODE) {
    console.log(`[SW ${SW_VERSION}] ðŸ”¥ Warming up cache with CDN dependencies...`);
  }
  const cache = await caches.open('external-dependencies');

  const fetchPromises = CRITICAL_CDN_URLS.map(async (url) => {
    try {
      if (DEV_MODE) console.log(`[SW ${SW_VERSION}] Fetching ${url}...`);
      const response = await fetch(url, { mode: 'cors', credentials: 'omit' });
      if (response.ok) {
        await cache.put(url, response);
        if (DEV_MODE) console.log(`[SW ${SW_VERSION}] âœ… Cached ${url}`);
      } else {
        // Always log errors
        console.error(`[SW ${SW_VERSION}] âŒ Failed to fetch ${url}: ${response.status}`);
      }
    } catch (error) {
      // Always log errors
      console.error(`[SW ${SW_VERSION}] âŒ Error fetching ${url}:`, error);
    }
  });

  await Promise.all(fetchPromises);
  if (DEV_MODE) {
    console.log(`[SW ${SW_VERSION}] ðŸ”¥ Cache warmup complete!`);
  }
}

// Force the new service worker to take control immediately
self.skipWaiting();
clientsClaim();

// Clean up old caches from previous versions
cleanupOutdatedCaches();

// Log install event and warmup cache
self.addEventListener('install', (event) => {
  if (DEV_MODE) {
    console.log(`[SW ${SW_VERSION}] INSTALL event - precaching assets`);
  }

  // Pre-fetch CDN dependencies during install
  event.waitUntil(warmupCache());
});

// Log activate event
self.addEventListener('activate', (event) => {
  if (DEV_MODE) {
    console.log(`[SW ${SW_VERSION}] ACTIVATE event - taking control`);
  }
});

// Precache all assets generated by Vite
if (DEV_MODE) {
  console.log(`[SW ${SW_VERSION}] Calling precacheAndRoute...`);
}
const manifest = self.__WB_MANIFEST;
if (DEV_MODE) {
  console.log(`[SW ${SW_VERSION}] Precache manifest has ${manifest.length} entries`);
}
precacheAndRoute(manifest);

// CRITICAL: Register navigation route to serve index.html for all navigation requests
// This is what makes the app work when launched from home screen offline
const navigationHandler = createHandlerBoundToURL('/index.html');
const navigationRoute = new NavigationRoute(navigationHandler, {
  denylist: [/^\/_/, /\/[^/?]+\.[^/]+$/], // Exclude special paths and file requests
});
registerRoute(navigationRoute);
if (DEV_MODE) {
  console.log(`[SW ${SW_VERSION}] âœ… Registered navigation route handler`);
}

// App Shell - Cache First
registerRoute(
  ({ url }) => url.origin === self.location.origin,
  new CacheFirst({
    cacheName: 'app-shell',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

// External CDN Dependencies (React, Framer Motion, Lucide) - Cache First
registerRoute(
  /^https:\/\/aistudiocdn\.com\/.*/i,
  new CacheFirst({
    cacheName: 'external-dependencies',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Unsplash Images - Cache First
registerRoute(
  /^https:\/\/images\.unsplash\.com\/.*/i,
  new CacheFirst({
    cacheName: 'tour-images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Google Fonts Stylesheets - Cache First
registerRoute(
  /^https:\/\/fonts\.googleapis\.com\/.*/i,
  new CacheFirst({
    cacheName: 'google-fonts-stylesheets',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  })
);

// Google Font Files - Cache First
registerRoute(
  /^https:\/\/fonts\.gstatic\.com\/.*/i,
  new CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  })
);

// Supabase Audio Files - Cache First
registerRoute(
  ({ url }) => {
    return (
      url.origin === 'https://ewrhpiibxstiipkqafwf.supabase.co' &&
      url.pathname.includes('/storage/v1/object/public/') &&
      (url.pathname.endsWith('.mp3') ||
        url.pathname.endsWith('.wav') ||
        url.pathname.endsWith('.m4a'))
    );
  },
  new CacheFirst({
    cacheName: 'tour-assets',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Supabase Images - Cache First
registerRoute(
  ({ url }) => {
    return (
      url.origin === 'https://ewrhpiibxstiipkqafwf.supabase.co' &&
      url.pathname.includes('/storage/v1/object/public/') &&
      (url.pathname.endsWith('.jpg') ||
        url.pathname.endsWith('.jpeg') ||
        url.pathname.endsWith('.png') ||
        url.pathname.endsWith('.webp'))
    );
  },
  new CacheFirst({
    cacheName: 'tour-assets',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Supabase Videos - Cache First
registerRoute(
  ({ url }) => {
    return (
      url.origin === 'https://ewrhpiibxstiipkqafwf.supabase.co' &&
      url.pathname.includes('/storage/v1/object/public/') &&
      (url.pathname.endsWith('.mp4') || url.pathname.endsWith('.webm'))
    );
  },
  new CacheFirst({
    cacheName: 'tour-assets',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Supabase 3D Models - Cache First
registerRoute(
  ({ url }) => {
    return (
      url.origin === 'https://ewrhpiibxstiipkqafwf.supabase.co' &&
      url.pathname.includes('/storage/v1/object/public/') &&
      (url.pathname.endsWith('.glb') || url.pathname.endsWith('.gltf'))
    );
  },
  new CacheFirst({
    cacheName: 'tour-assets',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// CRITICAL: Explicit navigation handler for iOS standalone mode
self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);
  const isNavigationRequest = event.request.mode === 'navigate';

  if (DEV_MODE) {
    console.log(`[SW ${SW_VERSION}] FETCH ${event.request.method} ${url.href}`, {
      mode: event.request.mode,
      destination: event.request.destination,
      isNavigation: isNavigationRequest,
      origin: url.origin,
    });
  }

  // Explicitly handle navigation requests by serving index.html from cache
  if (isNavigationRequest) {
    if (DEV_MODE) {
      console.log(`[SW ${SW_VERSION}] ðŸŽ¯ Navigation request detected - serving index.html from cache`);
    }

    event.respondWith(
      (async () => {
        try {
          // Try to get from network first (when online)
          if (navigator.onLine) {
            try {
              const networkResponse = await fetch(event.request);
              if (networkResponse.ok) {
                return networkResponse;
              }
            } catch (e) {
              // Network failed, fall through to cache
            }
          }

          // Serve from cache (offline or network failed)
          const cache = await caches.open('workbox-precache-v2-' + self.location.origin + '/');
          const keys = await cache.keys();

          // Find the cached index.html (it has a revision query param)
          const indexEntry = keys.find(req => req.url.includes('index.html'));

          if (indexEntry) {
            const cachedResponse = await cache.match(indexEntry);
            if (cachedResponse) {
              if (DEV_MODE) {
                console.log(`[SW ${SW_VERSION}] âœ… Serving index.html from cache`);
              }
              return cachedResponse;
            }
          }

          // Always log errors
          console.error(`[SW ${SW_VERSION}] âŒ index.html not found in cache!`);
          return new Response('Offline - index.html not cached', {
            status: 503,
            headers: { 'Content-Type': 'text/plain' }
          });
        } catch (error) {
          // Always log errors
          console.error(`[SW ${SW_VERSION}] âŒ Error handling navigation:`, error);
          return new Response('Service Worker Error: ' + (error as Error).message, {
            status: 500,
            headers: { 'Content-Type': 'text/plain' }
          });
        }
      })()
    );
  }
});

// Clean up old caches
self.addEventListener('activate', (event) => {
  if (DEV_MODE) {
    console.log(`[SW ${SW_VERSION}] ACTIVATE - cleaning old caches`);
  }
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      if (DEV_MODE) {
        console.log(`[SW ${SW_VERSION}] Found caches:`, cacheNames);
      }
      return Promise.all(
        cacheNames
          .filter((cacheName) => {
            // Delete old caches that don't match current cache names
            const shouldDelete = !cacheName.match(
              /^(app-shell|external-dependencies|tour-images|google-fonts-stylesheets|google-fonts-webfonts|tour-assets|workbox-precache)/
            );
            if (DEV_MODE && shouldDelete) {
              console.log(`[SW ${SW_VERSION}] Deleting old cache: ${cacheName}`);
            }
            return shouldDelete;
          })
          .map((cacheName) => caches.delete(cacheName))
      );
    })
  );
});
